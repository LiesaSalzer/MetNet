%\VignetteEngine{knitr::knitr}
%\VignetteIndexEntry{Workflow for Metabolomics}
%\VignetteKeywords{Mass Spectrometry, MS, MSMS, Metabolomics, Visualization}
%\VignettePackage{MetNet-vignette}

\documentclass[11pt,a4paper,english,arial,twoside]{article}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{geometry}
\geometry{verbose,
    tmargin=25mm,
    bmargin=25mm,
    lmargin=25mm,
    rmargin=25mm}
\setlength\parindent{0pt}

\usepackage{amsmath,amsfonts,amssymb,amsthm}
\usepackage{mathtools}
\usepackage{textcomp}
\usepackage{longtable}

%\definecolor{red}{rgb}{1,0,0}
%\definecolor{blue}{rgb}{0,0,1}

%\usepackage{breakurl}
\usepackage{hyperref}
\hypersetup{%
  pdfusetitle,
  bookmarks = {true},
  bookmarksnumbered = {true},
  bookmarksopen = {true},
  bookmarksopenlevel = 2,
  unicode = {true},
  breaklinks = {false},
  hyperindex = {true},
  colorlinks = {true},
  linktocpage = {true},
  plainpages = {false},
  linkcolor = {blue},
  citecolor = {blue},
  urlcolor = {red},
  pdfstartview = {Fit},
  pdfpagemode = {UseOutlines},
  pdfview = {XYZ null null null}
}

\widowpenalty10000
\clubpenalty10000

\newcommand{\email}[1]{\href{mailto:#1}{\normalfont\texttt{#1}}}
\newcommand{\R}{\texttt{R}}
\newcommand{\code}[1]{{\texttt{#1}}}
\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\mbox{\normalfont\textsf{#1}}}}


\newcommand\numberthis{\addtocounter{equation}{1}\tag{\theequation}}

\usepackage[nottoc]{tocbibind}

\usepackage[utf8]{inputenc}
\usepackage{fancyhdr}

\usepackage{graphicx}
%\usepackage[font=footnotesize]{subfig}

\usepackage[english]{babel}
\usepackage{color}

\usepackage[backend=bibtex,natbib,style=authoryear,maxcitenames=2]{biblatex}
\addbibresource{MetNet-citations}

\usepackage{setspace}
\onehalfspacing

\usepackage{authblk} 
\author[]{Thomas Naake}



\affil{
    Max Planck Institute of Molecular Plant Physiology \\ 
    14476 Potsdam-Golm, Germany 
}

\title{MetNet: Inferring metabolic networks from untargeted mass spectrometry 
    data}
    
\begin{document}

\maketitle

\section{Introduction}
Among the main challenges in mass spectrometry analysis is the high-throughput 
analysis of metabolic features, their fast detection and annotation. 
In contrast to the screening of known, previously characterized,
metabolic features in these data, the putative annotation of unknown 
features is often cumbersome and requires a lot of manual work, lagging
the biological information retrieval of these data. 
High-resolution mass spectrometric data is often very rich in information 
content and metabolic conversions, and reactions can be derived from structural 
properties of features. In addition to that, statistical associations between 
features (based on their intensity values) can be a valuable ressource to 
find co-synthesised or co-regulated metabolites, that are synthesised in the same 
biosynthetic pathways. Since any analysis tool is still lacking that is 
integrating the two natures of mass spectrometric data we developped 
\Rpackage{MetNet} to close this gap. 
The \Rpackage{MetNet} package comprises functionalities to infer network 
topologies from high-resolution mass spectrometry data. \Rpackage{MetNet} 
combines information from both structural data (differences in m/z values 
of features) and statistical associations (intensity values of features per
sample) to propose putative metabolic networks that can be used for further
exploration. 

Breitling 2006 Ab initio prediction
Jourdan 2007 MetaNetter 

The two main functionalities of the package include the creation of an
adjacency matrix from structual properties, based on losses/addition of 
functional groups defined by the user, and statistical associations. Currently,
the following statistical models are implemented to infer a statistical 
adjacency matrix: Least absolute shrinkage and selection operator 
(LASSO, L1-norm regression), Random Forest,
Pearson and Spearman correlation, context likelihood of relatedness (CLR), 
the algorithm for the reconstruction of accurate cellular networks (ARACNE) and
constraint-based structure learning (Bayes). Since all of these methods have
advantages and disadvantages, the user has the possibility to select 
several of these methods, compute adjacency matrices from these models and 
create a consensus matrix from the different statistical frameworks. 

After creating the statistical and structural network these two matrices 
will be combined to form a consensus matrix thta has both information from 
structural and statistical properties of the data. This can be followed by 
further network analyses (e.g. calculation of topological parameters),
integration with other data sources (e.g. genomic information or 
transcriptomic data) and/or visualization. 

\Rpackage{MetNet} is currently under active development. If you 
discover any bugs, typos or develop ideas of improving 
\Rpackage{MetNet} feel free to raise an issue via 
\href{https://github.com/tnaake/MetNet}{GitHub} or 
send a mail to the developer. 

<<knitr, include=FALSE, cache=FALSE>>=
library("knitr")
@

\section{Prepare the environment and load the data}
To install \Rpackage{MetNet} enter the following to the \R~console
<<eval=FALSE>>=
source("https://bioconductor.org/biocLite.R")
biocLite("MetNet")
@

Before starting, load the \Rpackage{MetNet} package. This will also
load the required packages \Rpackage{glmnet}, \Rpackage{stabs}, 
\Rpackage{randomForest}, \Rpackage{rfPermute}, \Rpackage{mpmi}, 
\Rpackage{parmigene}, \Rpackage{psych} and \Rpackage{bnlearn}. 
<<eval=TRUE>>=
library(MetNet)
@

The data format that is compatible with the \Rpackage{MetNet} framework is 
in the \Rpackage{xcms}/\Rpackage{CAMERA} output-like $m x n$ matrix, where 
columns denote the different samples $n$ and where $m$ features are present. 
The information about the m/z values has to be stored in a vector of 
length $|m|$. \Rpackage{MetNet} does not impose any requirements for 
data normalization, filtering, etc. However, the user has to make sure that
the data is in an appropriate format. These include division by internal standard, 
log2 transformation, noise filtering, removal of features that do not represent
mass features/metabolites, removal of isotopes, etc. 

<<data,eval=TRUE,echo=TRUE>>=
data("x_test", package = "MetNet")
x_test <- as.matrix
@

\section{Creating the structural matrix}
The function \Rfunction{create_structural_network} will create the adjacency
matrix based on structual properties (m/z values) of the features. 
The function expects a matrix with a column \code{"mz"} 
that contains the m/z value of the corresponding features. Furthermore, 
\Rfunction{create_structural_network} takes a \Robject{data.frame} 
object as argument \Robject{functional_groups} with the \code{colnames} 
\code{"mass"}, \code{"name"} and additional columns (e.g. \code{"formula"}). The 
numerical values in the column \code{"mass"} will define for what 
additions/losses the function \Rfunction{create_structural_network} will 
look for in the differences of the m/z feature values. Hereby, 
\Rfunction{create_structural_network} will take into account the \Robject{ppm} 
value, to adjust for inaccuracies in m/z values due to technical reasons
according to the formula

\begin{equation}
    ppm = \frac{m_{exp} - m_{calc}}{m_{exp}}  \cdot 10$^{-6}$
    
\end{equation}

with $m_{exp}$ the experimentally determined m/z value and $m_{calc}$ the 
calculated accurate mass of a molecule. Within the function, a lower and upper 
range is calculated depending on the supplied \Robject{ppm} value, differences
between the m/z feature values are calculated and matched against the 
\code{"mass"}es of the \Robject{functional_groups} argument. If any 
of the additions/losses defined in \Robject{functional_groups} is found in the 
data, it will be reported as an (unweighted) connection in the 
returned adjacency matrix. Together with the adjacency matrix the type of 
connection (derived from the column \code{"name"} in the 
\Robject{functional_groups}) will be written to a character matrix. These 
two matrices will be returned as a list (first entry: numerical adjacency
matrix, second entry: character matrix) by the function 
\Rfunction{create_structural_network}. 

<<functional_groups,echo=TRUE,eval=TRUE>>=
functional_groups <- rbind(
    c("Hydroxylation (–H)", "O", "15.9949146221"),
    c("Malonyl group (–H2O)", "C3H2O3", "86.0003939305"),
    c("C6H10O6", "C6H10O6", "178.0477380536"),
    c("D-ribose (–H2O) (ribosylation)", "C5H8O4", "132.0422587452"),
    c("Disaccharide (–H2O)", "C12H20O11", "340.1005614851"),
    c("Glucuronic acid (–H2O)", "C6H8O6", "176.0320879894"),
    c("Monosaccharide (–H2O)", "C6H10O5", "162.0528234315"),
    c("Trisaccharide (–H2O)", "C18H30O15", "486.1584702945"))
functional_groups <- data.frame(group = functional_groups[,1],
                            formula = functional_groups[,2],
                            mass = as.numeric(functional_groups[,3]))
@

<<structure,eval=TRUE,echo=TRUE>>=
struct_adj <- create_structural_matrix(x_test, functional_groups, ppm = 5)
@


\section{Creating the statistical matrix}

The function \Rfunction{create_statistical_network} will create the adjacency
matrix based on statistical associations. \Rfunction{create_statistical_network}
is a wrapper function for the functions 
\Rfunction{create_statistical_networks_list} and \Rfunction{consensus_network}. 
The function \Rfunction{create_statistical_networks_list} will create a 
list of adjacency matrices using the statistical models defined by the 
\Robject{model} argument. Currently, the models LASSO, Random Forest, 
CLR, ARACNE (the two latter using the functions \Rfunction{clr} and 
\Rfunction{aracne.a} from the \Rpackage{parmigene} package, 
based on Mutual Information calculation), Pearson 
and Spearman correlation and constraint-based structure learnging (based on 
the Fast Incremental Association, Fast-IAMB, algorithm from the \Rpackage{bnlearn}
package). For furthe information on the different models take a look on the 
respective help pages of \code{.lasso}, \code{.randomForest}, \code{.clr},
\code{.aracne}, \code{?.correlation} and/or \code{.bayes}. Functions that are 
accepted by the respective underlying functions can be passed directly to 
the \Rfunction{create_statistical_network} and 
\Rfunction{create_statistical_networks_list} functions. In addition, arguments 
that are defined in the functions \code{.lasso}, \code{.randomForest}, 
\code{.clr}, \code{.aracne}, \code{?.correlation} and/or \code{.bayes} can 
be passed like-wise to the functions. 

From the list of adjacency matrices the function \Rfunction{conensus_network}
will create a consensus adjacency matrix using the employed statistical models.
The reasoning behing this step is to circumvent disadvantages arising from each 
model and creating a statistically reliable topology that reflects the actual 
metabolic relations. To calculate the consensus adjacency matrix, the 
\Rfunction{consensus} from the \Rpackage{sna} is employed. The arguments that 
are accepted by this function can be passed to the \Rfunction{consensus_network}
and \Rfunction{create_statistical_network} function, respectively. Furthermore, 
in case another method than \code{"central.graph"} is used the argument
\Robject{threshold} will define if the value $a_{i,j}$ of the consensus matrix 
will be reported as a connection in the returned matrix (if $a_{i,j} \geq$ \code{threshold})
or not. \Rfunction{create_statistical_network} and \Rfunction{consensus_network}
will return an unweighted adjancency matrix with connections inferred from the
respective models. 

In the following example, we will create a consensus adjacency matrix using 
Pearson and Spearman correlation using the intensity values as input data. 
The p-values that will be used for assigning edges in the unweighted 
adjacency matrix will be adjusted by the Benjamini & Hochberg (False Discovery 
rate) method and the default q-value of 0.05. 
<<statistical>>=
x_int <- x_test[,-3:dim(x_test)[2]]
stat_adj <- create_statistical_network(x_x_int, 
                model = c("pearson", "spearman"), adjust_correlation = "BH")
@

To create the same adjacency matrix without using the wrapper function, you can
call the two functions \Rfunction{create_statistical_networks_list} and 
\Rfunction{consensus_network} individually: 
<<statistical_stepwise>>= 
l <- create_statistical_networks_list(x_int, model = c("pearson", "spearman"),  adjust_correlation = "BH")
stat_adj <- consensus_network(l = l)
@

\section{Combining the structural and statistical matrix}
After creating the structural and statistical matrix, it is time to combine 
these two matrices. The function \Rfunction{combine_structural_statistical} 
will combine the matrices to the consensus matrix. The function accepts 
the arguments \code{structure} and \code{statistical} for the two matrices,
respectively, and the argument \code{threshold}, that is a numerical value 
(default = 1). After adding the matrices, the entries will be checked if 
they are greater or equal than \code{threshold} and 1 or 0, will be returned. 
The argument \code{threshold} needs to be adjusted if another \code{method} 
than \code{"central.graph"} in 
\Rfunction{create_statistical_network}/\Rfunction{consensus_network} is used. 

<<combine>>=
cons_adj <- combine_structural_statistical(structure = struct_adj,
                                    statistical = stat_adj)
@

\section{Visualization and further analyses}
To display the createed consensus adjacency matrix, visualisation tools 
available in the \R framework can be employed or any other visualisation tool
after exporting the consensus matrix as a text file. In this example 
we will use the \Rpackage{igraph} to visualize the adjacency matrix. 

<<visualisation,eval=TRUE,echo=TRUE>>=
g <- graph_fromadjacency_matrix(matrix = cons_adj, mode = "directed", 
                           directed = FALSE)
plot(g)
@

\begin{figure}[h!]
    \center
    \includegraphics{./figure/visualisation-1}
    \caption{}
\end{figure}

Furthermore, the adjacency matrix can be analysed by network analysis techniques
(topological parameters such as centrality, ...) that are implemented in 
different packages in \R (e.g. \Rpackage{igraph} or \Rpackage{sna}). 

\newpage
\printbibliography

\newpage 
\section*{Appendix}

\subsection*{Session information}

All software and respective versions to build this vignette are listed here:
<<session,eval=TRUE,echo=FALSE>>=
sessionInfo()
@

\newpage
\subsection*{Functional groups}

The list of functional groups is taken from \citet{Breitling2006}. The numerical
m/z values were calculated by using the structural formula and the 
Biological Magnetic Resonance Data Bank
\href{http://www.bmrb.wisc.edu/metabolomics/mol_mass.php}{web tool}. 
<<functional_groups,eval=TRUE,echo=TRUE>>=
functional_groups <- rbind(
    c("Alanine", "C3H5NO", "71.0371137878"),
    c("Arginine", "C6H12N4O", "156.1011110281"),
    c("Asparagine", "C4H6N2O2", "114.0429274472"),
    c("Guanosine 5-diphosphate (–H2O)", "C10H13N5O10P2", "425.0137646843"),
    c("Guanosine 5-monophosphate (–H2O)", "C10H12N5O7P", "345.0474342759"),
    c("Guanine (–H)", "C5H4N5O", "150.0415847765"),
    c("Aspartic acid", "C4H5NO3", "115.0269430320"),
    c("Guanosine (–H2O)", "C10H11N5O4", "265.0811038675"),
    c("Cysteine", "C3H5NOS", "103.0091844778"),
    c("Deoxythymidine 5'-diphosphate (–H2O)", "C10H14N2O10P2", "384.0123677008"),
    c("Cystine", "C6H10N2O3S2", "222.0132835777"),
    c("Thymidine (–H2O)", "C10H12N2O4", "224.0797068840"),
    c("Glutamic acid", "C5H7NO3", "129.0425930962"),
    c("Thymine (–H)", "C5H5N2O2", "125.0351024151"),
    c("Glutamine", "C5H8N2O2", "128.0585775114"),
    c("Thymidine 5'-monophosphate (–H2O)", "C10H13N2O7P", "304.0460372924"),
    c("Glycine", "C2H3NO", "57.0214637236"),
    c("Uridine 5'-diphosphate (–H2O)", "C9H12N2O11P2", "385.9916322587"),
    c("Histidine", "C6H7N3O", "137.0589118624"),
    c("Uridine 5'-monophosphate (–H2O)", "C9H11N2O8P", "306.0253018503"),
    c("Isoleucine", "C6H11NO", "113.0840639804"),
    c("Uracil (–H)", "C4H3N2O2", "111.0194523509"),
    c("Leucine", "C6H11NO", "113.0840639804"),
    c("Uridine (–H2O)", "C9H10N2O5", "226.0589714419"),
    c("Lysine", "C6H12N2O", "128.0949630177"),
    c("Acetylation (–H)", "C2H3O2", "59.0133043405"),
    c("Methionine", "C5H9NOS", "131.0404846062"),
    c("Acetylation (–H2O)", "C2H2O",  "42.0105646863"),
    c("Phenylalanine", "C9H9NO",  "147.0684139162"),
    c("C2H2", "C2H2", "26.0156500642"),
    c("Proline", "C5H7NO", "97.0527638520"),
    c("Carboxylation", "CO2", "43.9898292442"),
    c("Serine", "C3H5NO2", "87.0320284099"),
    c("CHO2", "CHO2", "44.9976542763"),
    c("Threonine",  "C4H7NO2",  "101.0476784741"),
    c("Condensation/dehydration", "H2O", "18.0105646863"),
    c("Tryptophan", "C11H10N2O",  "186.0793129535"),
    c("Diphosphate", "H3O6P2", "160.9404858489"),
    c("Tyrosine", "C9H9NO2", "163.0633285383"),
    c("Ethyl addition (–H2O)", "C2H4", "28.0313001284"),
    c("Valine", "C5H9NO",  "99.0684139162"),
    c("Formic Acid (–H2O)", "CO", "27.9949146221"),
    c("Acetotacetate (–H2O)",  "C4H4O2", "84.0211293726"),
    c("Glyoxylate (–H2O)", "C2O2",  "55.9898292442"),
    c("Acetone (–H)", "C3H5O", "57.0340397826"),
    c("Hydrogenation/dehydrogenation", "H2", "2.0156500642"),
    c("Adenylate (–H2O)", "C10H12N5O6P", "329.0525196538"),
    c("Hydroxylation (–H)", "O", "15.9949146221"),
    c("Biotinyl (–H)", "C10H15N2O3S", "243.0803380482"),
    c("Inorganic phosphate", "P", "30.9737615100"),
    c("Biotinyl (–H2O)", "C10H14N2O2S", "226.0775983940"),
    c("Ketol group (–H2O)", "C2H2O", "42.0105646863"),
    c("Carbamoyl P transfer (–H2PO4)", "CH2ON", "44.0136386915"),
    c("Methanol (–H2O)", "CH2", "14.0156500642"),
    c("Co-enzyme A (–H)", "C21H34N7O16P3S", "765.0995583014"),
    c("Phosphate", "HPO3", "79.9663304084"),
    c("Co-enzyme A (–H2O)", "C21H33N7O15P3S", "748.0968186472"),
    c("Primary amine", "NH2", "16.0187240694"),
    c("Glutathione (–H2O)", "C10H15N3O5S", "289.0732412976"),
    c("Pyrophosphate", "PP", "61.9475230200"),
    c("Isoprene addition (–H)", "C5H7", "67.0547752247"),
    c("Secondary amine", "NH", "15.0108990373"),
    c("Malonyl group (–H2O)", "C3H2O3", "86.0003939305"),
    c("Sulfate (–H2O)", "SO3", "79.9568145563"),
    c("Palmitoylation (–H2O)", "C16H30O", "238.2296655851"),
    c("Tertiary amine", "N", "14.0030740052"),
    c("Pyridoxal phosphate (–H2O)", "C8H8NO5P", "229.0140088825"),
    c("C6H10O5", "C6H10O5", "162.0528234315"),
    c("Urea addition (–H)", "CH3N2O", "59.0245377288"),
    c("C6H10O6", "C6H10O6", "178.0477380536"),
    c("Adenine (–H)", "C5H4N5", "134.0466701544"),
    c("D-ribose (–H2O) (ribosylation)", "C5H8O4", "132.0422587452"),
    c("Adenosine (–H2O)", "C10H11N5O3", "249.0861892454"),
    c("Disaccharide (–H2O)", "C12H20O11", "340.1005614851"),
    c("Adenosine 5'-diphosphate (–H2O)", "C10H13N5O9P2", "409.0188500622"),
    c("Glucose-N-phosphate (–H2O)", "C6H11O8P", "242.0191538399"),
    c("Adenosine 5'-monophosphate (–H2O)", "C10H12N5O6P", "329.0525196538"),
    c("Glucuronic acid (–H2O)", "C6H8O6", "176.0320879894"),
    c("Cytidine 5'-diphosphate (–H2O)", "C9H13N3O10P2", "385.0076166739"),
    c("Monosaccharide (–H2O)", "C6H10O5", "162.0528234315"),
    c("Cytidine 5'-monophsophate (–H2O)", "C9H12N3O7P", "305.0412862655"),
    c("Trisaccharide (–H2O)", "C18H30O15", "486.1584702945"),
    c("Cytosine (–H)", "C4H4N3O",  "110.0354367661"))

functional_groups <- data.frame(name = functional_groups[,1], 
            formula = functional_groups[,2],
            mass = as.numeric(functional_groups[,3]))
@

\end{document}